After testing the final prototype, it's performance and ability to be used for it's intended domain can now be discussed.

The prototype basis's itself from both types of transfer methodologies, being a combination of a streaming and block level protocol. With the ability to limit the amount of acknowledgements that are required to a minimum using them only for acknowledging control (request) packets allowing many data chunks to be sent, potentially reducing the total time on a high latency network.

Compared to the investigated existing protocols, the prototype is able to recover from lost and out-of-order packets.

Compared to the existing protocols the prototype seems unsuited for transferring larger files, as shown in the photo test, where the amount of overhead was significant. However seems more suited to transfer smaller files such as plain-text data. Greatly improving over the traditional protocols FTP and SMB, however rsync still seems to have the least amount of overhead. On a network with limited packet loss the prototype requires less waiting for acknowledgements during file data exchange, because of it using UDP with many of the chunked packets being acknowledged in a single request packet.

Using this prototype in the file synchronisation domain, rsync still seems a more suitable choice as it has many features that this prototype lacks. For example the ability to diff the files removing the need to send a whole file on an update if one already exists greatly reduces the amount of data transferred. Although in a later prototype these could be added during the file handshake. However the protocol would have to be changed to a more block level methodology with each block being an equal size, since checksums would need to be exchanged to determine the file difference at either end.

A feature none of the investigated protocols have; is the ability to have a long running connection with no constant ping packets to maintain the connection. This is possible as UDP is being used and each client that connects is given a unique ID that could potentially be stored in a database for intermittent file transfers without the need to constantly establish a new connection, removing the need to keep sending handshakes. A use case where "connection-less" long running file transfers could be used is synchronisation of files across a low bandwidth shared network where activity is intermittent and it is guarantied to not have many transfers.
